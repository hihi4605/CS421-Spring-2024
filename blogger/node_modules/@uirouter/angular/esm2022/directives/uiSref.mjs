import { extend, isNumber, isNullOrUndefined } from '@uirouter/core';
import { Directive, Inject, Input, Optional, HostListener, } from '@angular/core';
import { UIView } from './uiView';
import { ReplaySubject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@uirouter/core";
/**
 * @internal
 * # blah blah blah
 */
export class AnchorUISref {
    _el;
    _renderer;
    constructor(_el, _renderer) {
        this._el = _el;
        this._renderer = _renderer;
    }
    openInNewTab() {
        return this._el.nativeElement.target === '_blank';
    }
    update(href) {
        if (!isNullOrUndefined(href)) {
            this._renderer.setProperty(this._el.nativeElement, 'href', href);
        }
        else {
            this._renderer.removeAttribute(this._el.nativeElement, 'href');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: AnchorUISref, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.0.9", type: AnchorUISref, selector: "a[uiSref]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: AnchorUISref, decorators: [{
            type: Directive,
            args: [{ selector: 'a[uiSref]' }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }] });
/**
 * A directive when clicked, initiates a [[Transition]] to a [[TargetState]].
 *
 * ### Purpose
 *
 * This directive is applied to anchor tags (`<a>`) or any other clickable element.  It is a state reference (or sref --
 * similar to an href).  When clicked, the directive will transition to that state by calling [[StateService.go]],
 * and optionally supply state parameter values and transition options.
 *
 * When this directive is on an anchor tag, it will also add an `href` attribute to the anchor.
 *
 * ### Selector
 *
 * - `[uiSref]`: The directive is created as an attribute on an element, e.g., `<a uiSref></a>`
 *
 * ### Inputs
 *
 * - `uiSref`: the target state's name, e.g., `uiSref="foostate"`.  If a component template uses a relative `uiSref`,
 * e.g., `uiSref=".child"`, the reference is relative to that component's state.
 *
 * - `uiParams`: any target state parameter values, as an object, e.g., `[uiParams]="{ fooId: bar.fooId }"`
 *
 * - `uiOptions`: [[TransitionOptions]], e.g., `[uiOptions]="{ inherit: false }"`
 *
 * @example
 * ```html
 *
 * <!-- Targets bar state' -->
 * <a uiSref="bar">Bar</a>
 *
 * <!-- Assume this component's state is "foo".
 *      Relatively targets "foo.child" -->
 * <a uiSref=".child">Foo Child</a>
 *
 * <!-- Targets "bar" state and supplies parameter value -->
 * <a uiSref="bar" [uiParams]="{ barId: foo.barId }">Bar {{foo.barId}}</a>
 *
 * <!-- Targets "bar" state and parameter, doesn't inherit existing parameters-->
 * <a uiSref="bar" [uiParams]="{ barId: foo.barId }" [uiOptions]="{ inherit: false }">Bar {{foo.barId}}</a>
 * ```
 */
export class UISref {
    /**
     * `@Input('uiSref')` The name of the state to link to
     *
     * ```html
     * <a uiSref="hoome">Home</a>
     * ```
     */
    state;
    /**
     * `@Input('uiParams')` The parameter values to use (as key/values)
     *
     * ```html
     * <a uiSref="book" [uiParams]="{ bookId: book.id }">Book {{ book.name }}</a>
     * ```
     */
    params;
    /**
     * `@Input('uiOptions')` The transition options
     *
     * ```html
     * <a uiSref="books" [uiOptions]="{ reload: true }">Book {{ book.name }}</a>
     * ```
     */
    options;
    /**
     * An observable (ReplaySubject) of the state this UISref is targeting.
     * When the UISref is clicked, it will transition to this [[TargetState]].
     */
    targetState$ = new ReplaySubject(1);
    /** @internal */ _emit = false;
    /** @internal */ _statesSub;
    /** @internal */ _router;
    /** @internal */ _anchorUISref;
    /** @internal */ _parent;
    constructor(_router, _anchorUISref, parent) {
        this._router = _router;
        this._anchorUISref = _anchorUISref;
        this._parent = parent;
        this._statesSub = _router.globals.states$.subscribe(() => this.update());
    }
    /** @internal */
    set uiSref(val) {
        this.state = val;
        this.update();
    }
    /** @internal */
    set uiParams(val) {
        this.params = val;
        this.update();
    }
    /** @internal */
    set uiOptions(val) {
        this.options = val;
        this.update();
    }
    ngOnInit() {
        this._emit = true;
        this.update();
    }
    ngOnChanges(changes) {
        this.update();
    }
    ngOnDestroy() {
        this._emit = false;
        this._statesSub.unsubscribe();
        this.targetState$.unsubscribe();
    }
    update() {
        const $state = this._router.stateService;
        if (this._emit) {
            const newTarget = $state.target(this.state, this.params, this.getOptions());
            this.targetState$.next(newTarget);
        }
        if (this._anchorUISref) {
            if (!this.state) {
                this._anchorUISref.update(null);
            }
            else {
                const href = $state.href(this.state, this.params, this.getOptions()) || '';
                this._anchorUISref.update(href);
            }
        }
    }
    getOptions() {
        const defaultOpts = {
            relative: this._parent && this._parent.context && this._parent.context.name,
            inherit: true,
            source: 'sref',
        };
        return extend(defaultOpts, this.options || {});
    }
    /** When triggered by a (click) event, this function transitions to the UISref's target state */
    go(button, ctrlKey, metaKey) {
        if ((this._anchorUISref &&
            (this._anchorUISref.openInNewTab() || button || !isNumber(button) || ctrlKey || metaKey)) ||
            !this.state) {
            return;
        }
        this._router.stateService.go(this.state, this.params, this.getOptions());
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: UISref, deps: [{ token: i1.UIRouter }, { token: AnchorUISref, optional: true }, { token: UIView.PARENT_INJECT }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.0.9", type: UISref, selector: "[uiSref]", inputs: { state: ["uiSref", "state"], params: ["uiParams", "params"], options: ["uiOptions", "options"] }, host: { listeners: { "click": "go($event.button,$event.ctrlKey,$event.metaKey)" } }, exportAs: ["uiSref"], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: UISref, decorators: [{
            type: Directive,
            args: [{
                    selector: '[uiSref]',
                    exportAs: 'uiSref',
                }]
        }], ctorParameters: () => [{ type: i1.UIRouter }, { type: AnchorUISref, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [UIView.PARENT_INJECT]
                }] }], propDecorators: { state: [{
                type: Input,
                args: ['uiSref']
            }], params: [{
                type: Input,
                args: ['uiParams']
            }], options: [{
                type: Input,
                args: ['uiOptions']
            }], go: [{
                type: HostListener,
                args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWlTcmVmLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2RpcmVjdGl2ZXMvdWlTcmVmLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBWSxNQUFNLEVBQW9ELFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2pJLE9BQU8sRUFDTCxTQUFTLEVBQ1QsTUFBTSxFQUNOLEtBQUssRUFDTCxRQUFRLEVBS1IsWUFBWSxHQUNiLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxNQUFNLEVBQXNCLE1BQU0sVUFBVSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxhQUFhLEVBQWdCLE1BQU0sTUFBTSxDQUFDOzs7QUFFbkQ7OztHQUdHO0FBRUgsTUFBTSxPQUFPLFlBQVk7SUFDSjtJQUF3QjtJQUEzQyxZQUFtQixHQUFlLEVBQVMsU0FBb0I7UUFBNUMsUUFBRyxHQUFILEdBQUcsQ0FBWTtRQUFTLGNBQVMsR0FBVCxTQUFTLENBQVc7SUFBRyxDQUFDO0lBRW5FLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUM7SUFDcEQsQ0FBQztJQUVELE1BQU0sQ0FBQyxJQUFZO1FBQ2pCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbEU7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2hFO0lBQ0gsQ0FBQzt1R0FiVSxZQUFZOzJGQUFaLFlBQVk7OzJGQUFaLFlBQVk7a0JBRHhCLFNBQVM7bUJBQUMsRUFBRSxRQUFRLEVBQUUsV0FBVyxF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QUs7c0JBQXJCLEtBQUs7dUJBQUMsUUFBUTtnQkFTSSxNQUFNO3NCQUF4QixLQUFLO3VCQUFDLFVBQVU7Z0JBU0csT0FBTztzQkFBMUIsS0FBSzt1QkFBQyxXQUFXO2dCQXFGbEIsRUFBRTtzQkFERCxZQUFZO3VCQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVJUm91dGVyLCBleHRlbmQsIE9iaiwgU3RhdGVPck5hbWUsIFRyYW5zaXRpb25PcHRpb25zLCBUYXJnZXRTdGF0ZSwgaXNOdW1iZXIsIGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPcHRpb25hbCxcbiAgRWxlbWVudFJlZixcbiAgUmVuZGVyZXIyLFxuICBPbkNoYW5nZXMsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIEhvc3RMaXN0ZW5lcixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVSVZpZXcsIFBhcmVudFVJVmlld0luamVjdCB9IGZyb20gJy4vdWlWaWV3JztcbmltcG9ydCB7IFJlcGxheVN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogIyBibGFoIGJsYWggYmxhaFxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdhW3VpU3JlZl0nIH0pXG5leHBvcnQgY2xhc3MgQW5jaG9yVUlTcmVmIHtcbiAgY29uc3RydWN0b3IocHVibGljIF9lbDogRWxlbWVudFJlZiwgcHVibGljIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIG9wZW5Jbk5ld1RhYigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWwubmF0aXZlRWxlbWVudC50YXJnZXQgPT09ICdfYmxhbmsnO1xuICB9XG5cbiAgdXBkYXRlKGhyZWY6IHN0cmluZykge1xuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaHJlZikpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdocmVmJywgaHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLl9lbC5uYXRpdmVFbGVtZW50LCAnaHJlZicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoZW4gY2xpY2tlZCwgaW5pdGlhdGVzIGEgW1tUcmFuc2l0aW9uXV0gdG8gYSBbW1RhcmdldFN0YXRlXV0uXG4gKlxuICogIyMjIFB1cnBvc2VcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBhcHBsaWVkIHRvIGFuY2hvciB0YWdzIChgPGE+YCkgb3IgYW55IG90aGVyIGNsaWNrYWJsZSBlbGVtZW50LiAgSXQgaXMgYSBzdGF0ZSByZWZlcmVuY2UgKG9yIHNyZWYgLS1cbiAqIHNpbWlsYXIgdG8gYW4gaHJlZikuICBXaGVuIGNsaWNrZWQsIHRoZSBkaXJlY3RpdmUgd2lsbCB0cmFuc2l0aW9uIHRvIHRoYXQgc3RhdGUgYnkgY2FsbGluZyBbW1N0YXRlU2VydmljZS5nb11dLFxuICogYW5kIG9wdGlvbmFsbHkgc3VwcGx5IHN0YXRlIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHRyYW5zaXRpb24gb3B0aW9ucy5cbiAqXG4gKiBXaGVuIHRoaXMgZGlyZWN0aXZlIGlzIG9uIGFuIGFuY2hvciB0YWcsIGl0IHdpbGwgYWxzbyBhZGQgYW4gYGhyZWZgIGF0dHJpYnV0ZSB0byB0aGUgYW5jaG9yLlxuICpcbiAqICMjIyBTZWxlY3RvclxuICpcbiAqIC0gYFt1aVNyZWZdYDogVGhlIGRpcmVjdGl2ZSBpcyBjcmVhdGVkIGFzIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LCBlLmcuLCBgPGEgdWlTcmVmPjwvYT5gXG4gKlxuICogIyMjIElucHV0c1xuICpcbiAqIC0gYHVpU3JlZmA6IHRoZSB0YXJnZXQgc3RhdGUncyBuYW1lLCBlLmcuLCBgdWlTcmVmPVwiZm9vc3RhdGVcImAuICBJZiBhIGNvbXBvbmVudCB0ZW1wbGF0ZSB1c2VzIGEgcmVsYXRpdmUgYHVpU3JlZmAsXG4gKiBlLmcuLCBgdWlTcmVmPVwiLmNoaWxkXCJgLCB0aGUgcmVmZXJlbmNlIGlzIHJlbGF0aXZlIHRvIHRoYXQgY29tcG9uZW50J3Mgc3RhdGUuXG4gKlxuICogLSBgdWlQYXJhbXNgOiBhbnkgdGFyZ2V0IHN0YXRlIHBhcmFtZXRlciB2YWx1ZXMsIGFzIGFuIG9iamVjdCwgZS5nLiwgYFt1aVBhcmFtc109XCJ7IGZvb0lkOiBiYXIuZm9vSWQgfVwiYFxuICpcbiAqIC0gYHVpT3B0aW9uc2A6IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSwgZS5nLiwgYFt1aU9wdGlvbnNdPVwieyBpbmhlcml0OiBmYWxzZSB9XCJgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqXG4gKiA8IS0tIFRhcmdldHMgYmFyIHN0YXRlJyAtLT5cbiAqIDxhIHVpU3JlZj1cImJhclwiPkJhcjwvYT5cbiAqXG4gKiA8IS0tIEFzc3VtZSB0aGlzIGNvbXBvbmVudCdzIHN0YXRlIGlzIFwiZm9vXCIuXG4gKiAgICAgIFJlbGF0aXZlbHkgdGFyZ2V0cyBcImZvby5jaGlsZFwiIC0tPlxuICogPGEgdWlTcmVmPVwiLmNoaWxkXCI+Rm9vIENoaWxkPC9hPlxuICpcbiAqIDwhLS0gVGFyZ2V0cyBcImJhclwiIHN0YXRlIGFuZCBzdXBwbGllcyBwYXJhbWV0ZXIgdmFsdWUgLS0+XG4gKiA8YSB1aVNyZWY9XCJiYXJcIiBbdWlQYXJhbXNdPVwieyBiYXJJZDogZm9vLmJhcklkIH1cIj5CYXIge3tmb28uYmFySWR9fTwvYT5cbiAqXG4gKiA8IS0tIFRhcmdldHMgXCJiYXJcIiBzdGF0ZSBhbmQgcGFyYW1ldGVyLCBkb2Vzbid0IGluaGVyaXQgZXhpc3RpbmcgcGFyYW1ldGVycy0tPlxuICogPGEgdWlTcmVmPVwiYmFyXCIgW3VpUGFyYW1zXT1cInsgYmFySWQ6IGZvby5iYXJJZCB9XCIgW3VpT3B0aW9uc109XCJ7IGluaGVyaXQ6IGZhbHNlIH1cIj5CYXIge3tmb28uYmFySWR9fTwvYT5cbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdWlTcmVmXScsXG4gIGV4cG9ydEFzOiAndWlTcmVmJyxcbn0pXG5leHBvcnQgY2xhc3MgVUlTcmVmIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIGBASW5wdXQoJ3VpU3JlZicpYCBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gbGluayB0b1xuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhIHVpU3JlZj1cImhvb21lXCI+SG9tZTwvYT5cbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoJ3VpU3JlZicpIHN0YXRlOiBTdGF0ZU9yTmFtZTtcblxuICAvKipcbiAgICogYEBJbnB1dCgndWlQYXJhbXMnKWAgVGhlIHBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlIChhcyBrZXkvdmFsdWVzKVxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhIHVpU3JlZj1cImJvb2tcIiBbdWlQYXJhbXNdPVwieyBib29rSWQ6IGJvb2suaWQgfVwiPkJvb2sge3sgYm9vay5uYW1lIH19PC9hPlxuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dCgndWlQYXJhbXMnKSBwYXJhbXM6IGFueTtcblxuICAvKipcbiAgICogYEBJbnB1dCgndWlPcHRpb25zJylgIFRoZSB0cmFuc2l0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YSB1aVNyZWY9XCJib29rc1wiIFt1aU9wdGlvbnNdPVwieyByZWxvYWQ6IHRydWUgfVwiPkJvb2sge3sgYm9vay5uYW1lIH19PC9hPlxuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dCgndWlPcHRpb25zJykgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEFuIG9ic2VydmFibGUgKFJlcGxheVN1YmplY3QpIG9mIHRoZSBzdGF0ZSB0aGlzIFVJU3JlZiBpcyB0YXJnZXRpbmcuXG4gICAqIFdoZW4gdGhlIFVJU3JlZiBpcyBjbGlja2VkLCBpdCB3aWxsIHRyYW5zaXRpb24gdG8gdGhpcyBbW1RhcmdldFN0YXRlXV0uXG4gICAqL1xuICBwdWJsaWMgdGFyZ2V0U3RhdGUkID0gbmV3IFJlcGxheVN1YmplY3Q8VGFyZ2V0U3RhdGU+KDEpO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfZW1pdCA9IGZhbHNlO1xuICAvKiogQGludGVybmFsICovIHByaXZhdGUgX3N0YXRlc1N1YjogU3Vic2NyaXB0aW9uO1xuICAvKiogQGludGVybmFsICovIHByaXZhdGUgX3JvdXRlcjogVUlSb3V0ZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfYW5jaG9yVUlTcmVmOiBBbmNob3JVSVNyZWY7XG4gIC8qKiBAaW50ZXJuYWwgKi8gcHJpdmF0ZSBfcGFyZW50OiBQYXJlbnRVSVZpZXdJbmplY3Q7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgX3JvdXRlcjogVUlSb3V0ZXIsXG4gICAgQE9wdGlvbmFsKCkgX2FuY2hvclVJU3JlZjogQW5jaG9yVUlTcmVmLFxuICAgIEBJbmplY3QoVUlWaWV3LlBBUkVOVF9JTkpFQ1QpIHBhcmVudDogUGFyZW50VUlWaWV3SW5qZWN0XG4gICkge1xuICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XG4gICAgdGhpcy5fYW5jaG9yVUlTcmVmID0gX2FuY2hvclVJU3JlZjtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICB0aGlzLl9zdGF0ZXNTdWIgPSBfcm91dGVyLmdsb2JhbHMuc3RhdGVzJC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldCB1aVNyZWYodmFsOiBTdGF0ZU9yTmFtZSkge1xuICAgIHRoaXMuc3RhdGUgPSB2YWw7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldCB1aVBhcmFtcyh2YWw6IE9iaikge1xuICAgIHRoaXMucGFyYW1zID0gdmFsO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXQgdWlPcHRpb25zKHZhbDogVHJhbnNpdGlvbk9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB2YWw7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX2VtaXQgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2VtaXQgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZXNTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLnRhcmdldFN0YXRlJC51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUoKSB7XG4gICAgY29uc3QgJHN0YXRlID0gdGhpcy5fcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICBpZiAodGhpcy5fZW1pdCkge1xuICAgICAgY29uc3QgbmV3VGFyZ2V0ID0gJHN0YXRlLnRhcmdldCh0aGlzLnN0YXRlLCB0aGlzLnBhcmFtcywgdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgdGhpcy50YXJnZXRTdGF0ZSQubmV4dChuZXdUYXJnZXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmNob3JVSVNyZWYpIHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgICB0aGlzLl9hbmNob3JVSVNyZWYudXBkYXRlKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaHJlZiA9ICRzdGF0ZS5ocmVmKHRoaXMuc3RhdGUsIHRoaXMucGFyYW1zLCB0aGlzLmdldE9wdGlvbnMoKSkgfHwgJyc7XG4gICAgICAgIHRoaXMuX2FuY2hvclVJU3JlZi51cGRhdGUoaHJlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCBkZWZhdWx0T3B0czogVHJhbnNpdGlvbk9wdGlvbnMgPSB7XG4gICAgICByZWxhdGl2ZTogdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5jb250ZXh0ICYmIHRoaXMuX3BhcmVudC5jb250ZXh0Lm5hbWUsXG4gICAgICBpbmhlcml0OiB0cnVlLFxuICAgICAgc291cmNlOiAnc3JlZicsXG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kKGRlZmF1bHRPcHRzLCB0aGlzLm9wdGlvbnMgfHwge30pO1xuICB9XG5cbiAgLyoqIFdoZW4gdHJpZ2dlcmVkIGJ5IGEgKGNsaWNrKSBldmVudCwgdGhpcyBmdW5jdGlvbiB0cmFuc2l0aW9ucyB0byB0aGUgVUlTcmVmJ3MgdGFyZ2V0IHN0YXRlICovXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQuYnV0dG9uJywgJyRldmVudC5jdHJsS2V5JywgJyRldmVudC5tZXRhS2V5J10pXG4gIGdvKGJ1dHRvbjogbnVtYmVyLCBjdHJsS2V5OiBib29sZWFuLCBtZXRhS2V5OiBib29sZWFuKSB7XG4gICAgaWYgKFxuICAgICAgKHRoaXMuX2FuY2hvclVJU3JlZiAmJlxuICAgICAgICAodGhpcy5fYW5jaG9yVUlTcmVmLm9wZW5Jbk5ld1RhYigpIHx8IGJ1dHRvbiB8fCAhaXNOdW1iZXIoYnV0dG9uKSB8fCBjdHJsS2V5IHx8IG1ldGFLZXkpKSB8fFxuICAgICAgIXRoaXMuc3RhdGVcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yb3V0ZXIuc3RhdGVTZXJ2aWNlLmdvKHRoaXMuc3RhdGUsIHRoaXMucGFyYW1zLCB0aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=