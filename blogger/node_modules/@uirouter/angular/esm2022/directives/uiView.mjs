import { Component, ComponentFactoryResolver, Inject, Injector, Input, ViewChild, ViewContainerRef, } from '@angular/core';
import { filter, inArray, isFunction, NATIVE_INJECTOR_TOKEN, parse, ResolveContext, trace, unnestR, } from '@uirouter/core';
import { Ng2ViewConfig } from '../statebuilders/views';
import { MergeInjector } from '../mergeInjector';
import * as i0 from "@angular/core";
import * as i1 from "@uirouter/core";
import * as i2 from "@angular/common";
/** @hidden */
let id = 0;
/**
 * Given a component class, gets the inputs of styles:
 *
 * - @Input('foo') _foo
 * - `inputs: ['foo']`
 *
 * @internal
 */
const ng2ComponentInputs = (factory) => {
    return factory.inputs.map((input) => ({ prop: input.propName, token: input.templateName }));
};
/**
 * A UI-Router viewport directive, which is filled in by a view (component) on a state.
 *
 * ### Selector
 *
 * A `ui-view` directive can be created as an element: `<ui-view></ui-view>` or as an attribute: `<div ui-view></div>`.
 *
 * ### Purpose
 *
 * This directive is used in a Component template (or as the root component) to create a viewport.  The viewport
 * is filled in by a view (as defined by a [[Ng2ViewDeclaration]] inside a [[Ng2StateDeclaration]]) when the view's
 * state has been activated.
 *
 * #### Example:
 * ```js
 * // This app has two states, 'foo' and 'bar'
 * stateRegistry.register({ name: 'foo', url: '/foo', component: FooComponent });
 * stateRegistry.register({ name: 'bar', url: '/bar', component: BarComponent });
 * ```
 * ```html
 * <!-- This ui-view will be filled in by the foo state's component or
 *      the bar state's component when the foo or bar state is activated -->
 * <ui-view></ui-view>
 * ```
 *
 * ### Named ui-views
 *
 * A `ui-view` may optionally be given a name via the attribute value: `<div ui-view='header'></div>`.  *Note:
 * an unnamed `ui-view` is internally named `$default`*.   When a `ui-view` has a name, it will be filled in
 * by a matching named view.
 *
 * #### Example:
 * ```js
 * stateRegistry.register({
 *   name: 'foo',
 *   url: '/foo',
 *   views: { header: HeaderComponent, $default: FooComponent });
 * ```
 * ```html
 * <!-- When 'foo' state is active, filled by HeaderComponent -->
 * <div ui-view="header"></div>
 *
 * <!-- When 'foo' state is active, filled by FooComponent -->
 * <ui-view></ui-view>
 * ```
 */
export class UIView {
    router;
    viewContainerRef;
    static PARENT_INJECT = 'UIView.PARENT_INJECT';
    _componentTarget;
    name;
    set _name(val) {
        this.name = val;
    }
    /** The reference to the component currently inside the viewport */
    _componentRef;
    /** Deregisters the ui-view from the view service */
    _deregisterUIView;
    /** Deregisters the master uiCanExit transition hook */
    _deregisterUiCanExitHook;
    /** Deregisters the master uiOnParamsChanged transition hook */
    _deregisterUiOnParamsChangedHook;
    /** Data about the this UIView */
    _uiViewData = {};
    _parent;
    constructor(router, parent, viewContainerRef) {
        this.router = router;
        this.viewContainerRef = viewContainerRef;
        this._parent = parent;
    }
    /**
     * @returns the UI-Router `state` that is filling this uiView, or `undefined`.
     */
    get state() {
        return parse('_uiViewData.config.viewDecl.$context.self')(this);
    }
    ngOnInit() {
        const router = this.router;
        const parentFqn = this._parent.fqn;
        const name = this.name || '$default';
        this._uiViewData = {
            $type: 'ng2',
            id: id++,
            name: name,
            fqn: parentFqn ? parentFqn + '.' + name : name,
            creationContext: this._parent.context,
            configUpdated: this._viewConfigUpdated.bind(this),
            config: undefined,
        };
        this._deregisterUiCanExitHook = router.transitionService.onBefore({}, (trans) => {
            return this._invokeUiCanExitHook(trans);
        });
        this._deregisterUiOnParamsChangedHook = router.transitionService.onSuccess({}, (trans) => this._invokeUiOnParamsChangedHook(trans));
        this._deregisterUIView = router.viewService.registerUIView(this._uiViewData);
    }
    /**
     * For each transition, checks the component loaded in the ui-view for:
     *
     * - has a uiCanExit() component hook
     * - is being exited
     *
     * If both are true, adds the uiCanExit component function as a hook to that singular Transition.
     */
    _invokeUiCanExitHook(trans) {
        const instance = this._componentRef && this._componentRef.instance;
        const uiCanExitFn = instance && instance.uiCanExit;
        if (isFunction(uiCanExitFn)) {
            const state = this.state;
            if (trans.exiting().indexOf(state) !== -1) {
                trans.onStart({}, function () {
                    return uiCanExitFn.call(instance, trans);
                });
            }
        }
    }
    /**
     * For each transition, checks if any param values changed and notify component
     */
    _invokeUiOnParamsChangedHook($transition$) {
        const instance = this._componentRef && this._componentRef.instance;
        const uiOnParamsChanged = instance && instance.uiOnParamsChanged;
        if (isFunction(uiOnParamsChanged)) {
            const viewState = this.state;
            const resolveContext = new ResolveContext(this._uiViewData.config.path);
            const viewCreationTrans = resolveContext.getResolvable('$transition$').data;
            // Exit early if the $transition$ is the same as the view was created within.
            // Exit early if the $transition$ will exit the state the view is for.
            if ($transition$ === viewCreationTrans || $transition$.exiting().indexOf(viewState) !== -1)
                return;
            const toParams = $transition$.params('to');
            const fromParams = $transition$.params('from');
            const getNodeSchema = (node) => node.paramSchema;
            const toSchema = $transition$.treeChanges('to').map(getNodeSchema).reduce(unnestR, []);
            const fromSchema = $transition$.treeChanges('from').map(getNodeSchema).reduce(unnestR, []);
            // Find the to params that have different values than the from params
            const changedToParams = toSchema.filter((param) => {
                const idx = fromSchema.indexOf(param);
                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
            });
            // Only trigger callback if a to param has changed or is new
            if (changedToParams.length) {
                const changedKeys = changedToParams.map((x) => x.id);
                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
                const newValues = filter(toParams, (val, key) => changedKeys.indexOf(key) !== -1);
                instance.uiOnParamsChanged(newValues, $transition$);
            }
        }
    }
    _disposeLast() {
        if (this._componentRef)
            this._componentRef.destroy();
        this._componentRef = null;
    }
    ngOnDestroy() {
        if (this._deregisterUIView)
            this._deregisterUIView();
        if (this._deregisterUiCanExitHook)
            this._deregisterUiCanExitHook();
        if (this._deregisterUiOnParamsChangedHook)
            this._deregisterUiOnParamsChangedHook();
        this._deregisterUIView = this._deregisterUiCanExitHook = this._deregisterUiOnParamsChangedHook = null;
        this._disposeLast();
    }
    /**
     * The view service is informing us of an updated ViewConfig
     * (usually because a transition activated some state and its views)
     */
    _viewConfigUpdated(config) {
        // The config may be undefined if there is nothing currently targeting this UIView.
        // Dispose the current component, if there is one
        if (!config)
            return this._disposeLast();
        // Only care about Ng2 configs
        if (!(config instanceof Ng2ViewConfig))
            return;
        // The "new" viewconfig is already applied, so exit early
        if (this._uiViewData.config === config)
            return;
        // This is a new ViewConfig.  Dispose the previous component
        this._disposeLast();
        trace.traceUIViewConfigUpdated(this._uiViewData, config && config.viewDecl.$context);
        this._applyUpdatedConfig(config);
        // Initiate change detection for the newly created component
        this._componentRef.changeDetectorRef.markForCheck();
    }
    _applyUpdatedConfig(config) {
        this._uiViewData.config = config;
        // Create the Injector for the routed component
        const context = new ResolveContext(config.path);
        const componentInjector = this._getComponentInjector(context);
        // Get the component class from the view declaration. TODO: allow promises?
        const componentClass = config.viewDecl.component;
        // Create the component
        const compFactoryResolver = componentInjector.get(ComponentFactoryResolver);
        const compFactory = compFactoryResolver.resolveComponentFactory(componentClass);
        this._componentRef = this._componentTarget.createComponent(compFactory, undefined, componentInjector);
        // Wire resolves to @Input()s
        this._applyInputBindings(compFactory, this._componentRef.instance, context, componentClass);
    }
    /**
     * Creates a new Injector for a routed component.
     *
     * Adds resolve values to the Injector
     * Adds providers from the NgModule for the state
     * Adds providers from the parent Component in the component tree
     * Adds a PARENT_INJECT view context object
     *
     * @returns an Injector
     */
    _getComponentInjector(context) {
        // Map resolves to "useValue: providers"
        const resolvables = context
            .getTokens()
            .map((token) => context.getResolvable(token))
            .filter((r) => r.resolved);
        const newProviders = resolvables.map((r) => ({ provide: r.token, useValue: context.injector().get(r.token) }));
        const parentInject = { context: this._uiViewData.config.viewDecl.$context, fqn: this._uiViewData.fqn };
        newProviders.push({ provide: UIView.PARENT_INJECT, useValue: parentInject });
        const parentComponentInjector = this.viewContainerRef.injector;
        const moduleInjector = context.getResolvable(NATIVE_INJECTOR_TOKEN).data;
        const mergedParentInjector = new MergeInjector(moduleInjector, parentComponentInjector);
        return Injector.create(newProviders, mergedParentInjector);
    }
    /**
     * Supplies component inputs with resolve data
     *
     * Finds component inputs which match resolves (by name) and sets the input value
     * to the resolve data.
     */
    _applyInputBindings(factory, component, context, componentClass) {
        const bindings = this._uiViewData.config.viewDecl['bindings'] || {};
        const explicitBoundProps = Object.keys(bindings);
        // Returns the actual component property for a renamed an input renamed using `@Input('foo') _foo`.
        // return the `_foo` property
        const renamedInputProp = (prop) => {
            const input = factory.inputs.find((i) => i.templateName === prop);
            return (input && input.propName) || prop;
        };
        // Supply resolve data to component as specified in the state's `bindings: {}`
        const explicitInputTuples = explicitBoundProps.reduce((acc, key) => acc.concat([{ prop: renamedInputProp(key), token: bindings[key] }]), []);
        // Supply resolve data to matching @Input('prop') or inputs: ['prop']
        const implicitInputTuples = ng2ComponentInputs(factory).filter((tuple) => !inArray(explicitBoundProps, tuple.prop));
        const addResolvable = (tuple) => ({
            prop: tuple.prop,
            resolvable: context.getResolvable(tuple.token),
        });
        const injector = context.injector();
        explicitInputTuples
            .concat(implicitInputTuples)
            .map(addResolvable)
            .filter((tuple) => tuple.resolvable && tuple.resolvable.resolved)
            .forEach((tuple) => {
            component[tuple.prop] = injector.get(tuple.resolvable.token);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: UIView, deps: [{ token: i1.UIRouter }, { token: UIView.PARENT_INJECT }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.9", type: UIView, selector: "ui-view, [ui-view]", inputs: { name: "name", _name: ["ui-view", "_name"] }, viewQueries: [{ propertyName: "_componentTarget", first: true, predicate: ["componentTarget"], descendants: true, read: ViewContainerRef, static: true }], exportAs: ["uiView"], ngImport: i0, template: `
    <ng-template #componentTarget></ng-template>
    <ng-content *ngIf="!_componentRef"></ng-content>
  `, isInline: true, dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.9", ngImport: i0, type: UIView, decorators: [{
            type: Component,
            args: [{
                    selector: 'ui-view, [ui-view]',
                    exportAs: 'uiView',
                    template: `
    <ng-template #componentTarget></ng-template>
    <ng-content *ngIf="!_componentRef"></ng-content>
  `,
                }]
        }], ctorParameters: () => [{ type: i1.UIRouter }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [UIView.PARENT_INJECT]
                }] }, { type: i0.ViewContainerRef }], propDecorators: { _componentTarget: [{
                type: ViewChild,
                args: ['componentTarget', { read: ViewContainerRef, static: true }]
            }], name: [{
                type: Input,
                args: ['name']
            }], _name: [{
                type: Input,
                args: ['ui-view']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWlWaWV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2RpcmVjdGl2ZXMvdWlWaWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBRVQsd0JBQXdCLEVBRXhCLE1BQU0sRUFDTixRQUFRLEVBQ1IsS0FBSyxFQUdMLFNBQVMsRUFDVCxnQkFBZ0IsR0FDakIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUVMLE1BQU0sRUFDTixPQUFPLEVBQ1AsVUFBVSxFQUNWLHFCQUFxQixFQUVyQixLQUFLLEVBRUwsY0FBYyxFQUVkLEtBQUssRUFJTCxPQUFPLEdBR1IsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7O0FBRWpELGNBQWM7QUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFjWDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLE9BQThCLEVBQWtCLEVBQUU7SUFDNUUsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzlGLENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2Q0c7QUFTSCxNQUFNLE9BQU8sTUFBTTtJQXlCUjtJQUVBO0lBMUJULE1BQU0sQ0FBQyxhQUFhLEdBQUcsc0JBQXNCLENBQUM7SUFHOUMsZ0JBQWdCLENBQW1CO0lBQ3BCLElBQUksQ0FBUztJQUU1QixJQUNJLEtBQUssQ0FBQyxHQUFXO1FBQ25CLElBQUksQ0FBQyxJ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LENBQUMsYUFBYTsyRkExQm5CLE1BQU0saU5BR3FCLGdCQUFnQixpRUFSNUM7OztHQUdUOzsyRkFFVSxNQUFNO2tCQVJsQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLFFBQVEsRUFBRSxRQUFRO29CQUNsQixRQUFRLEVBQUU7OztHQUdUO2lCQUNGOzswQkEyQkksTUFBTTsyQkFBQyxNQUFNLENBQUMsYUFBYTt3RUF0QjlCLGdCQUFnQjtzQkFEZixTQUFTO3VCQUFDLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBRXZELElBQUk7c0JBQWxCLEtBQUs7dUJBQUMsTUFBTTtnQkFHVCxLQUFLO3NCQURSLEtBQUs7dUJBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ29tcG9uZW50LFxyXG4gIENvbXBvbmVudEZhY3RvcnksXHJcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxyXG4gIENvbXBvbmVudFJlZixcclxuICBJbmplY3QsXHJcbiAgSW5qZWN0b3IsXHJcbiAgSW5wdXQsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBWaWV3Q2hpbGQsXHJcbiAgVmlld0NvbnRhaW5lclJlZixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7XHJcbiAgQWN0aXZlVUlWaWV3LFxyXG4gIGZpbHRlcixcclxuICBpbkFycmF5LFxyXG4gIGlzRnVuY3Rpb24sXHJcbiAgTkFUSVZFX0lOSkVDVE9SX1RPS0VOLFxyXG4gIFBhcmFtLFxyXG4gIHBhcnNlLFxyXG4gIFBhdGhOb2RlLFxyXG4gIFJlc29sdmVDb250ZXh0LFxyXG4gIFN0YXRlRGVjbGFyYXRpb24sXHJcbiAgdHJhY2UsXHJcbiAgVHJhbnNpdGlvbixcclxuICBUcmFuc2l0aW9uSG9va0ZuLFxyXG4gIFVJUm91dGVyLFxyXG4gIHVubmVzdFIsXHJcbiAgVmlld0NvbmZpZyxcclxuICBWaWV3Q29udGV4dCxcclxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XHJcbmltcG9ydCB7IE5nMlZpZXdDb25maWcgfSBmcm9tICcuLi9zdGF0ZWJ1aWxkZXJzL3ZpZXdzJztcclxuaW1wb3J0IHsgTWVyZ2VJbmplY3RvciB9IGZyb20gJy4uL21lcmdlSW5qZWN0b3InO1xyXG5cclxuLyoqIEBoaWRkZW4gKi9cclxubGV0IGlkID0gMDtcclxuXHJcbi8qKiBAaW50ZXJuYWwgVGhlc2UgYXJlIHByb3ZpZGUoKWQgYXMgdGhlIHN0cmluZyBVSVZpZXcuUEFSRU5UX0lOSkVDVCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBhcmVudFVJVmlld0luamVjdCB7XHJcbiAgY29udGV4dDogVmlld0NvbnRleHQ7XHJcbiAgZnFuOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuaW50ZXJmYWNlIElucHV0TWFwcGluZyB7XHJcbiAgdG9rZW46IHN0cmluZztcclxuICBwcm9wOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIGNvbXBvbmVudCBjbGFzcywgZ2V0cyB0aGUgaW5wdXRzIG9mIHN0eWxlczpcclxuICpcclxuICogLSBASW5wdXQoJ2ZvbycpIF9mb29cclxuICogLSBgaW5wdXRzOiBbJ2ZvbyddYFxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IG5nMkNvbXBvbmVudElucHV0cyA9IChmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PGFueT4pOiBJbnB1dE1hcHBpbmdbXSA9PiB7XHJcbiAgcmV0dXJuIGZhY3RvcnkuaW5wdXRzLm1hcCgoaW5wdXQpID0+ICh7IHByb3A6IGlucHV0LnByb3BOYW1lLCB0b2tlbjogaW5wdXQudGVtcGxhdGVOYW1lIH0pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIFVJLVJvdXRlciB2aWV3cG9ydCBkaXJlY3RpdmUsIHdoaWNoIGlzIGZpbGxlZCBpbiBieSBhIHZpZXcgKGNvbXBvbmVudCkgb24gYSBzdGF0ZS5cclxuICpcclxuICogIyMjIFNlbGVjdG9yXHJcbiAqXHJcbiAqIEEgYHVpLXZpZXdgIGRpcmVjdGl2ZSBjYW4gYmUgY3JlYXRlZCBhcyBhbiBlbGVtZW50OiBgPHVpLXZpZXc+PC91aS12aWV3PmAgb3IgYXMgYW4gYXR0cmlidXRlOiBgPGRpdiB1aS12aWV3PjwvZGl2PmAuXHJcbiAqXHJcbiAqICMjIyBQdXJwb3NlXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIHVzZWQgaW4gYSBDb21wb25lbnQgdGVtcGxhdGUgKG9yIGFzIHRoZSByb290IGNvbXBvbmVudCkgdG8gY3JlYXRlIGEgdmlld3BvcnQuICBUaGUgdmlld3BvcnRcclxuICogaXMgZmlsbGVkIGluIGJ5IGEgdmlldyAoYXMgZGVmaW5lZCBieSBhIFtbTmcyVmlld0RlY2xhcmF0aW9uXV0gaW5zaWRlIGEgW1tOZzJTdGF0ZURlY2xhcmF0aW9uXV0pIHdoZW4gdGhlIHZpZXcnc1xyXG4gKiBzdGF0ZSBoYXMgYmVlbiBhY3RpdmF0ZWQuXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogYGBganNcclxuICogLy8gVGhpcyBhcHAgaGFzIHR3byBzdGF0ZXMsICdmb28nIGFuZCAnYmFyJ1xyXG4gKiBzdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ2ZvbycsIHVybDogJy9mb28nLCBjb21wb25lbnQ6IEZvb0NvbXBvbmVudCB9KTtcclxuICogc3RhdGVSZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdiYXInLCB1cmw6ICcvYmFyJywgY29tcG9uZW50OiBCYXJDb21wb25lbnQgfSk7XHJcbiAqIGBgYFxyXG4gKiBgYGBodG1sXHJcbiAqIDwhLS0gVGhpcyB1aS12aWV3IHdpbGwgYmUgZmlsbGVkIGluIGJ5IHRoZSBmb28gc3RhdGUncyBjb21wb25lbnQgb3JcclxuICogICAgICB0aGUgYmFyIHN0YXRlJ3MgY29tcG9uZW50IHdoZW4gdGhlIGZvbyBvciBiYXIgc3RhdGUgaXMgYWN0aXZhdGVkIC0tPlxyXG4gKiA8dWktdmlldz48L3VpLXZpZXc+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgTmFtZWQgdWktdmlld3NcclxuICpcclxuICogQSBgdWktdmlld2AgbWF5IG9wdGlvbmFsbHkgYmUgZ2l2ZW4gYSBuYW1lIHZpYSB0aGUgYXR0cmlidXRlIHZhbHVlOiBgPGRpdiB1aS12aWV3PSdoZWFkZXInPjwvZGl2PmAuICAqTm90ZTpcclxuICogYW4gdW5uYW1lZCBgdWktdmlld2AgaXMgaW50ZXJuYWxseSBuYW1lZCBgJGRlZmF1bHRgKi4gICBXaGVuIGEgYHVpLXZpZXdgIGhhcyBhIG5hbWUsIGl0IHdpbGwgYmUgZmlsbGVkIGluXHJcbiAqIGJ5IGEgbWF0Y2hpbmcgbmFtZWQgdmlldy5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBgYGBqc1xyXG4gKiBzdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyKHtcclxuICogICBuYW1lOiAnZm9vJyxcclxuICogICB1cmw6ICcvZm9vJyxcclxuICogICB2aWV3czogeyBoZWFkZXI6IEhlYWRlckNvbXBvbmVudCwgJGRlZmF1bHQ6IEZvb0NvbXBvbmVudCB9KTtcclxuICogYGBgXHJcbiAqIGBgYGh0bWxcclxuICogPCEtLSBXaGVuICdmb28nIHN0YXRlIGlzIGFjdGl2ZSwgZmlsbGVkIGJ5IEhlYWRlckNvbXBvbmVudCAtLT5cclxuICogPGRpdiB1aS12aWV3PVwiaGVhZGVyXCI+PC9kaXY+XHJcbiAqXHJcbiAqIDwhLS0gV2hlbiAnZm9vJyBzdGF0ZSBpcyBhY3RpdmUsIGZpbGxlZCBieSBGb29Db21wb25lbnQgLS0+XHJcbiAqIDx1aS12aWV3PjwvdWktdmlldz5cclxuICogYGBgXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3VpLXZpZXcsIFt1aS12aWV3XScsXHJcbiAgZXhwb3J0QXM6ICd1aVZpZXcnLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8bmctdGVtcGxhdGUgI2NvbXBvbmVudFRhcmdldD48L25nLXRlbXBsYXRlPlxyXG4gICAgPG5nLWNvbnRlbnQgKm5nSWY9XCIhX2NvbXBvbmVudFJlZlwiPjwvbmctY29udGVudD5cclxuICBgLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVUlWaWV3IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG4gIHN0YXRpYyBQQVJFTlRfSU5KRUNUID0gJ1VJVmlldy5QQVJFTlRfSU5KRUNUJztcclxuXHJcbiAgQFZpZXdDaGlsZCgnY29tcG9uZW50VGFyZ2V0JywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSlcclxuICBfY29tcG9uZW50VGFyZ2V0OiBWaWV3Q29udGFpbmVyUmVmO1xyXG4gIEBJbnB1dCgnbmFtZScpIG5hbWU6IHN0cmluZztcclxuXHJcbiAgQElucHV0KCd1aS12aWV3JylcclxuICBzZXQgX25hbWUodmFsOiBzdHJpbmcpIHtcclxuICAgIHRoaXMubmFtZSA9IHZhbDtcclxuICB9XHJcblxyXG4gIC8qKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQgY3VycmVudGx5IGluc2lkZSB0aGUgdmlld3BvcnQgKi9cclxuICBfY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55PjtcclxuICAvKiogRGVyZWdpc3RlcnMgdGhlIHVpLXZpZXcgZnJvbSB0aGUgdmlldyBzZXJ2aWNlICovXHJcbiAgcHJpdmF0ZSBfZGVyZWdpc3RlclVJVmlldzogRnVuY3Rpb247XHJcbiAgLyoqIERlcmVnaXN0ZXJzIHRoZSBtYXN0ZXIgdWlDYW5FeGl0IHRyYW5zaXRpb24gaG9vayAqL1xyXG4gIHByaXZhdGUgX2RlcmVnaXN0ZXJVaUNhbkV4aXRIb29rOiBGdW5jdGlvbjtcclxuICAvKiogRGVyZWdpc3RlcnMgdGhlIG1hc3RlciB1aU9uUGFyYW1zQ2hhbmdlZCB0cmFuc2l0aW9uIGhvb2sgKi9cclxuICBwcml2YXRlIF9kZXJlZ2lzdGVyVWlPblBhcmFtc0NoYW5nZWRIb29rOiBGdW5jdGlvbjtcclxuICAvKiogRGF0YSBhYm91dCB0aGUgdGhpcyBVSVZpZXcgKi9cclxuICBwcml2YXRlIF91aVZpZXdEYXRhOiBBY3RpdmVVSVZpZXcgPSA8YW55Pnt9O1xyXG4gIHByaXZhdGUgX3BhcmVudDogUGFyZW50VUlWaWV3SW5qZWN0O1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHB1YmxpYyByb3V0ZXI6IFVJUm91dGVyLFxyXG4gICAgQEluamVjdChVSVZpZXcuUEFSRU5UX0lOSkVDVCkgcGFyZW50LFxyXG4gICAgcHVibGljIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWZcclxuICApIHtcclxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHRoZSBVSS1Sb3V0ZXIgYHN0YXRlYCB0aGF0IGlzIGZpbGxpbmcgdGhpcyB1aVZpZXcsIG9yIGB1bmRlZmluZWRgLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogU3RhdGVEZWNsYXJhdGlvbiB7XHJcbiAgICByZXR1cm4gcGFyc2UoJ191aVZpZXdEYXRhLmNvbmZpZy52aWV3RGVjbC4kY29udGV4dC5zZWxmJykodGhpcyk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIGNvbnN0IHJvdXRlciA9IHRoaXMucm91dGVyO1xyXG4gICAgY29uc3QgcGFyZW50RnFuID0gdGhpcy5fcGFyZW50LmZxbjtcclxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUgfHwgJyRkZWZhdWx0JztcclxuXHJcbiAgICB0aGlzLl91aVZpZXdEYXRhID0ge1xyXG4gICAgICAkdHlwZTogJ25nMicsXHJcbiAgICAgIGlkOiBpZCsrLFxyXG4gICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICBmcW46IHBhcmVudEZxbiA/IHBhcmVudEZxbiArICcuJyArIG5hbWUgOiBuYW1lLFxyXG4gICAgICBjcmVhdGlvbkNvbnRleHQ6IHRoaXMuX3BhcmVudC5jb250ZXh0LFxyXG4gICAgICBjb25maWdVcGRhdGVkOiB0aGlzLl92aWV3Q29uZmlnVXBkYXRlZC5iaW5kKHRoaXMpLFxyXG4gICAgICBjb25maWc6IHVuZGVmaW5lZCxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fZGVyZWdpc3RlclVpQ2FuRXhpdEhvb2sgPSByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sICh0cmFucykgPT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5faW52b2tlVWlDYW5FeGl0SG9vayh0cmFucyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9kZXJlZ2lzdGVyVWlPblBhcmFtc0NoYW5nZWRIb29rID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgKHRyYW5zKSA9PlxyXG4gICAgICB0aGlzLl9pbnZva2VVaU9uUGFyYW1zQ2hhbmdlZEhvb2sodHJhbnMpXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuX2RlcmVnaXN0ZXJVSVZpZXcgPSByb3V0ZXIudmlld1NlcnZpY2UucmVnaXN0ZXJVSVZpZXcodGhpcy5fdWlWaWV3RGF0YSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3IgZWFjaCB0cmFuc2l0aW9uLCBjaGVja3MgdGhlIGNvbXBvbmVudCBsb2FkZWQgaW4gdGhlIHVpLXZpZXcgZm9yOlxyXG4gICAqXHJcbiAgICogLSBoYXMgYSB1aUNhbkV4aXQoKSBjb21wb25lbnQgaG9va1xyXG4gICAqIC0gaXMgYmVpbmcgZXhpdGVkXHJcbiAgICpcclxuICAgKiBJZiBib3RoIGFyZSB0cnVlLCBhZGRzIHRoZSB1aUNhbkV4aXQgY29tcG9uZW50IGZ1bmN0aW9uIGFzIGEgaG9vayB0byB0aGF0IHNpbmd1bGFyIFRyYW5zaXRpb24uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW52b2tlVWlDYW5FeGl0SG9vayh0cmFuczogVHJhbnNpdGlvbikge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9jb21wb25lbnRSZWYgJiYgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlO1xyXG4gICAgY29uc3QgdWlDYW5FeGl0Rm46IFRyYW5zaXRpb25Ib29rRm4gPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS51aUNhbkV4aXQ7XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24odWlDYW5FeGl0Rm4pKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgIGlmICh0cmFucy5leGl0aW5nKCkuaW5kZXhPZihzdGF0ZSkgIT09IC0xKSB7XHJcbiAgICAgICAgdHJhbnMub25TdGFydCh7fSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHVpQ2FuRXhpdEZuLmNhbGwoaW5zdGFuY2UsIHRyYW5zKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yIGVhY2ggdHJhbnNpdGlvbiwgY2hlY2tzIGlmIGFueSBwYXJhbSB2YWx1ZXMgY2hhbmdlZCBhbmQgbm90aWZ5IGNvbXBvbmVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludm9rZVVpT25QYXJhbXNDaGFuZ2VkSG9vaygkdHJhbnNpdGlvbiQ6IFRyYW5zaXRpb24pIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fY29tcG9uZW50UmVmICYmIHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZTtcclxuICAgIGNvbnN0IHVpT25QYXJhbXNDaGFuZ2VkOiBUcmFuc2l0aW9uSG9va0ZuID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQ7XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24odWlPblBhcmFtc0NoYW5nZWQpKSB7XHJcbiAgICAgIGNvbnN0IHZpZXdTdGF0ZTogU3RhdGVEZWNsYXJhdGlvbiA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIGNvbnN0IHJlc29sdmVDb250ZXh0OiBSZXNvbHZlQ29udGV4dCA9IG5ldyBSZXNvbHZlQ29udGV4dCh0aGlzLl91aVZpZXdEYXRhLmNvbmZpZy5wYXRoKTtcclxuICAgICAgY29uc3Qgdmlld0NyZWF0aW9uVHJhbnMgPSByZXNvbHZlQ29udGV4dC5nZXRSZXNvbHZhYmxlKCckdHJhbnNpdGlvbiQnKS5kYXRhO1xyXG5cclxuICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIGlzIHRoZSBzYW1lIGFzIHRoZSB2aWV3IHdhcyBjcmVhdGVkIHdpdGhpbi5cclxuICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIHdpbGwgZXhpdCB0aGUgc3RhdGUgdGhlIHZpZXcgaXMgZm9yLlxyXG4gICAgICBpZiAoJHRyYW5zaXRpb24kID09PSB2aWV3Q3JlYXRpb25UcmFucyB8fCAkdHJhbnNpdGlvbiQuZXhpdGluZygpLmluZGV4T2Yodmlld1N0YXRlIGFzIFN0YXRlRGVjbGFyYXRpb24pICE9PSAtMSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjb25zdCB0b1BhcmFtczogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBhbnkgfSA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoJ3RvJyk7XHJcbiAgICAgIGNvbnN0IGZyb21QYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogYW55IH0gPSAkdHJhbnNpdGlvbiQucGFyYW1zKCdmcm9tJyk7XHJcbiAgICAgIGNvbnN0IGdldE5vZGVTY2hlbWEgPSAobm9kZTogUGF0aE5vZGUpID0+IG5vZGUucGFyYW1TY2hlbWE7XHJcbiAgICAgIGNvbnN0IHRvU2NoZW1hOiBQYXJhbVtdID0gJHRyYW5zaXRpb24kLnRyZWVDaGFuZ2VzKCd0bycpLm1hcChnZXROb2RlU2NoZW1hKS5yZWR1Y2UodW5uZXN0UiwgW10pO1xyXG4gICAgICBjb25zdCBmcm9tU2NoZW1hOiBQYXJhbVtdID0gJHRyYW5zaXRpb24kLnRyZWVDaGFuZ2VzKCdmcm9tJykubWFwKGdldE5vZGVTY2hlbWEpLnJlZHVjZSh1bm5lc3RSLCBbXSk7XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSB0byBwYXJhbXMgdGhhdCBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgdGhhbiB0aGUgZnJvbSBwYXJhbXNcclxuICAgICAgY29uc3QgY2hhbmdlZFRvUGFyYW1zID0gdG9TY2hlbWEuZmlsdGVyKChwYXJhbTogUGFyYW0pID0+IHtcclxuICAgICAgICBjb25zdCBpZHggPSBmcm9tU2NoZW1hLmluZGV4T2YocGFyYW0pO1xyXG4gICAgICAgIHJldHVybiBpZHggPT09IC0xIHx8ICFmcm9tU2NoZW1hW2lkeF0udHlwZS5lcXVhbHModG9QYXJhbXNbcGFyYW0uaWRdLCBmcm9tUGFyYW1zW3BhcmFtLmlkXSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gT25seSB0cmlnZ2VyIGNhbGxiYWNrIGlmIGEgdG8gcGFyYW0gaGFzIGNoYW5nZWQgb3IgaXMgbmV3XHJcbiAgICAgIGlmIChjaGFuZ2VkVG9QYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZEtleXM6IHN0cmluZ1tdID0gY2hhbmdlZFRvUGFyYW1zLm1hcCgoeCkgPT4geC5pZCk7XHJcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBwYXJhbXMgdG8gb25seSBjaGFuZ2VkL25ldyB0byBwYXJhbXMuICBgJHRyYW5zaXRpb24kLnBhcmFtcygpYCBtYXkgYmUgdXNlZCB0byBnZXQgYWxsIHBhcmFtcy5cclxuICAgICAgICBjb25zdCBuZXdWYWx1ZXMgPSBmaWx0ZXIodG9QYXJhbXMsICh2YWwsIGtleSkgPT4gY2hhbmdlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XHJcbiAgICAgICAgaW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQobmV3VmFsdWVzLCAkdHJhbnNpdGlvbiQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9kaXNwb3NlTGFzdCgpIHtcclxuICAgIGlmICh0aGlzLl9jb21wb25lbnRSZWYpIHRoaXMuX2NvbXBvbmVudFJlZi5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9jb21wb25lbnRSZWYgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5fZGVyZWdpc3RlclVJVmlldykgdGhpcy5fZGVyZWdpc3RlclVJVmlldygpO1xyXG4gICAgaWYgKHRoaXMuX2RlcmVnaXN0ZXJVaUNhbkV4aXRIb29rKSB0aGlzLl9kZXJlZ2lzdGVyVWlDYW5FeGl0SG9vaygpO1xyXG4gICAgaWYgKHRoaXMuX2RlcmVnaXN0ZXJVaU9uUGFyYW1zQ2hhbmdlZEhvb2spIHRoaXMuX2RlcmVnaXN0ZXJVaU9uUGFyYW1zQ2hhbmdlZEhvb2soKTtcclxuICAgIHRoaXMuX2RlcmVnaXN0ZXJVSVZpZXcgPSB0aGlzLl9kZXJlZ2lzdGVyVWlDYW5FeGl0SG9vayA9IHRoaXMuX2RlcmVnaXN0ZXJVaU9uUGFyYW1zQ2hhbmdlZEhvb2sgPSBudWxsO1xyXG4gICAgdGhpcy5fZGlzcG9zZUxhc3QoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB2aWV3IHNlcnZpY2UgaXMgaW5mb3JtaW5nIHVzIG9mIGFuIHVwZGF0ZWQgVmlld0NvbmZpZ1xyXG4gICAqICh1c3VhbGx5IGJlY2F1c2UgYSB0cmFuc2l0aW9uIGFjdGl2YXRlZCBzb21lIHN0YXRlIGFuZCBpdHMgdmlld3MpXHJcbiAgICovXHJcbiAgX3ZpZXdDb25maWdVcGRhdGVkKGNvbmZpZzogVmlld0NvbmZpZykge1xyXG4gICAgLy8gVGhlIGNvbmZpZyBtYXkgYmUgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vdGhpbmcgY3VycmVudGx5IHRhcmdldGluZyB0aGlzIFVJVmlldy5cclxuICAgIC8vIERpc3Bvc2UgdGhlIGN1cnJlbnQgY29tcG9uZW50LCBpZiB0aGVyZSBpcyBvbmVcclxuICAgIGlmICghY29uZmlnKSByZXR1cm4gdGhpcy5fZGlzcG9zZUxhc3QoKTtcclxuXHJcbiAgICAvLyBPbmx5IGNhcmUgYWJvdXQgTmcyIGNvbmZpZ3NcclxuICAgIGlmICghKGNvbmZpZyBpbnN0YW5jZW9mIE5nMlZpZXdDb25maWcpKSByZXR1cm47XHJcblxyXG4gICAgLy8gVGhlIFwibmV3XCIgdmlld2NvbmZpZyBpcyBhbHJlYWR5IGFwcGxpZWQsIHNvIGV4aXQgZWFybHlcclxuICAgIGlmICh0aGlzLl91aVZpZXdEYXRhLmNvbmZpZyA9PT0gY29uZmlnKSByZXR1cm47XHJcblxyXG4gICAgLy8gVGhpcyBpcyBhIG5ldyBWaWV3Q29uZmlnLiAgRGlzcG9zZSB0aGUgcHJldmlvdXMgY29tcG9uZW50XHJcbiAgICB0aGlzLl9kaXNwb3NlTGFzdCgpO1xyXG4gICAgdHJhY2UudHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKHRoaXMuX3VpVmlld0RhdGEsIGNvbmZpZyAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQpO1xyXG5cclxuICAgIHRoaXMuX2FwcGx5VXBkYXRlZENvbmZpZyhjb25maWcpO1xyXG5cclxuICAgIC8vIEluaXRpYXRlIGNoYW5nZSBkZXRlY3Rpb24gZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudFxyXG4gICAgdGhpcy5fY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfYXBwbHlVcGRhdGVkQ29uZmlnKGNvbmZpZzogTmcyVmlld0NvbmZpZykge1xyXG4gICAgdGhpcy5fdWlWaWV3RGF0YS5jb25maWcgPSBjb25maWc7XHJcbiAgICAvLyBDcmVhdGUgdGhlIEluamVjdG9yIGZvciB0aGUgcm91dGVkIGNvbXBvbmVudFxyXG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBSZXNvbHZlQ29udGV4dChjb25maWcucGF0aCk7XHJcbiAgICBjb25zdCBjb21wb25lbnRJbmplY3RvciA9IHRoaXMuX2dldENvbXBvbmVudEluamVjdG9yKGNvbnRleHQpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgY29tcG9uZW50IGNsYXNzIGZyb20gdGhlIHZpZXcgZGVjbGFyYXRpb24uIFRPRE86IGFsbG93IHByb21pc2VzP1xyXG4gICAgY29uc3QgY29tcG9uZW50Q2xhc3MgPSBjb25maWcudmlld0RlY2wuY29tcG9uZW50O1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgY29tcG9uZW50XHJcbiAgICBjb25zdCBjb21wRmFjdG9yeVJlc29sdmVyID0gY29tcG9uZW50SW5qZWN0b3IuZ2V0KENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XHJcbiAgICBjb25zdCBjb21wRmFjdG9yeSA9IGNvbXBGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50Q2xhc3MpO1xyXG4gICAgdGhpcy5fY29tcG9uZW50UmVmID0gdGhpcy5fY29tcG9uZW50VGFyZ2V0LmNyZWF0ZUNvbXBvbmVudChjb21wRmFjdG9yeSwgdW5kZWZpbmVkLCBjb21wb25lbnRJbmplY3Rvcik7XHJcblxyXG4gICAgLy8gV2lyZSByZXNvbHZlcyB0byBASW5wdXQoKXNcclxuICAgIHRoaXMuX2FwcGx5SW5wdXRCaW5kaW5ncyhjb21wRmFjdG9yeSwgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLCBjb250ZXh0LCBjb21wb25lbnRDbGFzcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IEluamVjdG9yIGZvciBhIHJvdXRlZCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBBZGRzIHJlc29sdmUgdmFsdWVzIHRvIHRoZSBJbmplY3RvclxyXG4gICAqIEFkZHMgcHJvdmlkZXJzIGZyb20gdGhlIE5nTW9kdWxlIGZvciB0aGUgc3RhdGVcclxuICAgKiBBZGRzIHByb3ZpZGVycyBmcm9tIHRoZSBwYXJlbnQgQ29tcG9uZW50IGluIHRoZSBjb21wb25lbnQgdHJlZVxyXG4gICAqIEFkZHMgYSBQQVJFTlRfSU5KRUNUIHZpZXcgY29udGV4dCBvYmplY3RcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGFuIEluamVjdG9yXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Q29tcG9uZW50SW5qZWN0b3IoY29udGV4dDogUmVzb2x2ZUNvbnRleHQpOiBJbmplY3RvciB7XHJcbiAgICAvLyBNYXAgcmVzb2x2ZXMgdG8gXCJ1c2VWYWx1ZTogcHJvdmlkZXJzXCJcclxuICAgIGNvbnN0IHJlc29sdmFibGVzID0gY29udGV4dFxyXG4gICAgICAuZ2V0VG9rZW5zKClcclxuICAgICAgLm1hcCgodG9rZW4pID0+IGNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbikpXHJcbiAgICAgIC5maWx0ZXIoKHIpID0+IHIucmVzb2x2ZWQpO1xyXG5cclxuICAgIGNvbnN0IG5ld1Byb3ZpZGVycyA9IHJlc29sdmFibGVzLm1hcCgocikgPT4gKHsgcHJvdmlkZTogci50b2tlbiwgdXNlVmFsdWU6IGNvbnRleHQuaW5qZWN0b3IoKS5nZXQoci50b2tlbikgfSkpO1xyXG5cclxuICAgIGNvbnN0IHBhcmVudEluamVjdCA9IHsgY29udGV4dDogdGhpcy5fdWlWaWV3RGF0YS5jb25maWcudmlld0RlY2wuJGNvbnRleHQsIGZxbjogdGhpcy5fdWlWaWV3RGF0YS5mcW4gfTtcclxuICAgIG5ld1Byb3ZpZGVycy5wdXNoKHsgcHJvdmlkZTogVUlWaWV3LlBBUkVOVF9JTkpFQ1QsIHVzZVZhbHVlOiBwYXJlbnRJbmplY3QgfSk7XHJcblxyXG4gICAgY29uc3QgcGFyZW50Q29tcG9uZW50SW5qZWN0b3IgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuaW5qZWN0b3I7XHJcbiAgICBjb25zdCBtb2R1bGVJbmplY3RvciA9IGNvbnRleHQuZ2V0UmVzb2x2YWJsZShOQVRJVkVfSU5KRUNUT1JfVE9LRU4pLmRhdGE7XHJcbiAgICBjb25zdCBtZXJnZWRQYXJlbnRJbmplY3RvciA9IG5ldyBNZXJnZUluamVjdG9yKG1vZHVsZUluamVjdG9yLCBwYXJlbnRDb21wb25lbnRJbmplY3Rvcik7XHJcblxyXG4gICAgcmV0dXJuIEluamVjdG9yLmNyZWF0ZShuZXdQcm92aWRlcnMsIG1lcmdlZFBhcmVudEluamVjdG9yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1cHBsaWVzIGNvbXBvbmVudCBpbnB1dHMgd2l0aCByZXNvbHZlIGRhdGFcclxuICAgKlxyXG4gICAqIEZpbmRzIGNvbXBvbmVudCBpbnB1dHMgd2hpY2ggbWF0Y2ggcmVzb2x2ZXMgKGJ5IG5hbWUpIGFuZCBzZXRzIHRoZSBpbnB1dCB2YWx1ZVxyXG4gICAqIHRvIHRoZSByZXNvbHZlIGRhdGEuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfYXBwbHlJbnB1dEJpbmRpbmdzKGZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55PiwgY29tcG9uZW50OiBhbnksIGNvbnRleHQ6IFJlc29sdmVDb250ZXh0LCBjb21wb25lbnRDbGFzcykge1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB0aGlzLl91aVZpZXdEYXRhLmNvbmZpZy52aWV3RGVjbFsnYmluZGluZ3MnXSB8fCB7fTtcclxuICAgIGNvbnN0IGV4cGxpY2l0Qm91bmRQcm9wcyA9IE9iamVjdC5rZXlzKGJpbmRpbmdzKTtcclxuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBhY3R1YWwgY29tcG9uZW50IHByb3BlcnR5IGZvciBhIHJlbmFtZWQgYW4gaW5wdXQgcmVuYW1lZCB1c2luZyBgQElucHV0KCdmb28nKSBfZm9vYC5cclxuICAgIC8vIHJldHVybiB0aGUgYF9mb29gIHByb3BlcnR5XHJcbiAgICBjb25zdCByZW5hbWVkSW5wdXRQcm9wID0gKHByb3A6IHN0cmluZykgPT4ge1xyXG4gICAgICBjb25zdCBpbnB1dCA9IGZhY3RvcnkuaW5wdXRzLmZpbmQoKGkpID0+IGkudGVtcGxhdGVOYW1lID09PSBwcm9wKTtcclxuICAgICAgcmV0dXJuIChpbnB1dCAmJiBpbnB1dC5wcm9wTmFtZSkgfHwgcHJvcDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gU3VwcGx5IHJlc29sdmUgZGF0YSB0byBjb21wb25lbnQgYXMgc3BlY2lmaWVkIGluIHRoZSBzdGF0ZSdzIGBiaW5kaW5nczoge31gXHJcbiAgICBjb25zdCBleHBsaWNpdElucHV0VHVwbGVzID0gZXhwbGljaXRCb3VuZFByb3BzLnJlZHVjZShcclxuICAgICAgKGFjYywga2V5KSA9PiBhY2MuY29uY2F0KFt7IHByb3A6IHJlbmFtZWRJbnB1dFByb3Aoa2V5KSwgdG9rZW46IGJpbmRpbmdzW2tleV0gfV0pLFxyXG4gICAgICBbXVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTdXBwbHkgcmVzb2x2ZSBkYXRhIHRvIG1hdGNoaW5nIEBJbnB1dCgncHJvcCcpIG9yIGlucHV0czogWydwcm9wJ11cclxuICAgIGNvbnN0IGltcGxpY2l0SW5wdXRUdXBsZXMgPSBuZzJDb21wb25lbnRJbnB1dHMoZmFjdG9yeSkuZmlsdGVyKCh0dXBsZSkgPT4gIWluQXJyYXkoZXhwbGljaXRCb3VuZFByb3BzLCB0dXBsZS5wcm9wKSk7XHJcblxyXG4gICAgY29uc3QgYWRkUmVzb2x2YWJsZSA9ICh0dXBsZTogSW5wdXRNYXBwaW5nKSA9PiAoe1xyXG4gICAgICBwcm9wOiB0dXBsZS5wcm9wLFxyXG4gICAgICByZXNvbHZhYmxlOiBjb250ZXh0LmdldFJlc29sdmFibGUodHVwbGUudG9rZW4pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaW5qZWN0b3IgPSBjb250ZXh0LmluamVjdG9yKCk7XHJcblxyXG4gICAgZXhwbGljaXRJbnB1dFR1cGxlc1xyXG4gICAgICAuY29uY2F0KGltcGxpY2l0SW5wdXRUdXBsZXMpXHJcbiAgICAgIC5tYXAoYWRkUmVzb2x2YWJsZSlcclxuICAgICAgLmZpbHRlcigodHVwbGUpID0+IHR1cGxlLnJlc29sdmFibGUgJiYgdHVwbGUucmVzb2x2YWJsZS5yZXNvbHZlZClcclxuICAgICAgLmZvckVhY2goKHR1cGxlKSA9PiB7XHJcbiAgICAgICAgY29tcG9uZW50W3R1cGxlLnByb3BdID0gaW5qZWN0b3IuZ2V0KHR1cGxlLnJlc29sdmFibGUudG9rZW4pO1xyXG4gICAgICB9KTtcclxuICB9XHJcbn1cclxuIl19